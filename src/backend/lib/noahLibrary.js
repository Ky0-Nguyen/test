import HDKey from 'ethereumjs-wallet-react-native/hdkey'
import bip39 from 'react-native-bip39'
import BigNumber from 'bignumber.js'
import EthereumTx from 'ethereumjs-tx'

import EtherscanServices from '../services/etherscanService'
import Settings from '../services/settings'
// NoahLibrary
export default class NoahLibrary {
  static async generateWallet (mnemonic, index) {
    if (!mnemonic) {
      mnemonic = await bip39.generateMnemonic()
    }
    var masterSeed = bip39.mnemonicToSeed(mnemonic)
    var wallet = HDKey.fromMasterSeed(masterSeed).derivePath("m/44'/60'/0'/0").deriveChild(index).getWallet()
    var currentReceiveAddress = '0x' + wallet.getAddress().toString('hex')
    var privatekey = wallet.getPrivateKey().toString('hex')
    return { currentReceiveAddress, privatekey, mnemonic }
  }

  static convertWeiToBalance (value, decimal) {
    return parseInt(value) / Math.pow(10, decimal || 18)
  }

  static convertBalanceToWei (value, decimal) {
    return value * Math.pow(10, decimal || 18)
  }

  /**
   * NAME: getEtherBalance
   * PARAMS: address to get balance
   * get balance of the specified address
   * RETURN balance
   */
  static async getEtherBalance (address) {
    try {
      let weiBalance = await EtherscanServices.getEtherBalance(address)
      return this.convertWeiToBalance(weiBalance)
    } catch (error) {
      return Number.NaN
    }
  }

  /**
   * NAME: getEtherBalanceMinusGas
   * PARAMS: senderAddress, receiverAddress
   * get balance after subtracting gas when sending to specified address
   * RETURN balance
   */
  static async getEtherBalanceMinusGas (ethAddress, toAddress) {
    let weiBalance = await EtherscanServices.getEtherBalance(ethAddress)

    try {
      // Check whether the receiver is external account or smart contract
      let gas = await this.getFee(toAddress)

      weiBalance -= gas

      let ethEstimatedSpendable = this.convertWeiToBalance(weiBalance)
      return ethEstimatedSpendable
    } catch (error) {
      return Number.NaN
    }
  }

  /**
   * NAME: getEtherBalanceMinusGas
   * PARAMS: senderAddress, receiverAddress
   * get balance after subtracting gas when sending to specified address
   * RETURN balance
   */
  static async getTokenFee (toAddress) {
    try {
      // Check whether the receiver is external account or smart contract
      let gas = await this.getFee(toAddress)

      return this.convertWeiToBalance(gas)
    } catch (error) {
      return Number.NaN
    }
  }

  /**
   * NAME: getFee
   * PARAMS: receiverAddress
   * get the gas generated by transfer ether to the destination address
   * RETURN
   */
  static async getFee (toAddress) {
    try {
    // Check whether the receiver is external account or smart contract
      let code = await EtherscanServices.getCode(toAddress)
      let gasPrice = await EtherscanServices.getGasPrice()
      // gasPrice *= countPercent
      gasPrice = parseFloat(gasPrice.toFixed(0))

      if (code === '0x') {
        return Settings.gas.externalAcc * gasPrice
      } else {
        let gasLimit = '0xffffffffffff'
        let estimateGas = await EtherscanServices.estimateGas(toAddress, '0xff22', gasPrice, gasLimit)
        let fee = (estimateGas + Settings.gas.extraGas) * gasPrice

        return fee
      }
    } catch (error) {
      throw error
    }
  }

  /**
   * NAME: getFee
   * PARAMS: receiverAddress
   * get the gas generated by transfer ether to the destination address
   * RETURN
   */
  static async getFeeToken (receiverAddress, contractAddress) {
    try {
    // Check whether the receiver is external account or smart contract
      let gasPrice = await EtherscanServices.getGasPrice()
      // gasPrice *= countPercent
      gasPrice = parseInt(gasPrice)

      var tokenAmount = 0
      // Token Standards
      var transferOpCode = '0xa9059cbb'

      var ethNakedAddress = receiverAddress.toLowerCase().replace('0x', '')

      // Convert to address Token
      var ABIAddressTarget = this.zeroPadLeft(ethNakedAddress, 64)

      // Convert to value Token
      var ABIValueToTransfer = this.zeroPadLeft(tokenAmount.toString(16), 64)
      var ethData = transferOpCode + ABIAddressTarget + ABIValueToTransfer

      let gasLimit = await this.getGasLimitToken(contractAddress, gasPrice, ethData)
      let fee = gasLimit * gasPrice

      return fee
    } catch (error) {
      throw error
    }
  }

  static async getGasLimitToken (contractAddress, gasPrice, data) {
    try {
      // Check whether the receiver is external account or smart contract
      // let limit = '0xffffffffffff'
      // let estimateGas = await EtherscanServices.estimateGasToken(contractAddress, data, gasPrice, limit)
      // let gasLimit = parseInt(estimateGas)
      return Settings.gas.externalToken
    } catch (error) {
      throw error
    }
  }

  /**
   * NAME: getGasLimit
   * PARAMS: receiverAddress
   * get the gas limit by transfer ether to the destination address
   * RETURN
   */
  static async getGasLimit (toAddress, gasPrice) {
    try {
      // Check whether the receiver is external account or smart contract
      let code = await EtherscanServices.getCode(toAddress)

      if (code === '0x') {
        return Settings.gas.externalAcc
      } else {
        let limit = '0xffffffffffff'
        let estimateGas = await EtherscanServices.estimateGas(toAddress, '0xff22', gasPrice, limit)
        let gasLimit = (estimateGas + Settings.gas.extraGas)

        return gasLimit
      }
    } catch (error) {
      throw error
    }
  }

  static zeroPadLeft (text, length) {
    while (text.length < length) {
      text = '0' + text
    }
    return text
  }

  /**
   * NAME: sendEtherAction
   * PARAMS: senderAddress, senderPrivateKey, receiverAddress, sendAmount
   * Perform send ethereum action to the specific address
   * RETURN true if successfully sent, false if send failed
   */
  static async sendEtherAction (senderAddress, senderPrivateKey, receiverAddress, sendAmount) {
    let privateKey = Buffer.from(senderPrivateKey, 'hex')
    // Get the neccessary information to create raw transaction
    let nonce = await EtherscanServices.getNounce(senderAddress)
    let gasPrice = await EtherscanServices.getGasPrice()
    // gasPrice *= countPercent
    let gasLimit = await this.getGasLimit(receiverAddress)
    let value = new BigNumber(this.convertBalanceToWei(sendAmount))
    value = '0x' + value.toString(16)

    let data = ''
    // Create raw transaction
    gasPrice = parseFloat(gasPrice.toFixed(0))
    let rawTransaction = {
      nonce: nonce,
      gasPrice: '0x' + gasPrice.toString(16),
      gasLimit: '0x' + gasLimit.toString(16),
      to: receiverAddress,
      value: value,
      data: data
    }
    // Create transaction and sign with private key
    var transaction = new EthereumTx(rawTransaction)
    transaction.sign(privateKey)

    // Serialize and convert transaction to hex
    let serializedTransaction = transaction.serialize()
    let hexSerializedTransaction = '0x' + serializedTransaction.toString('hex')
    return EtherscanServices.sendRawTransaction(hexSerializedTransaction)
  }

  static async sendTokenAction (senderAddress, senderPrivateKey, receiverAddress, sendAmount, contractAddress, decimal) {
    let privateKey = Buffer.from(senderPrivateKey, 'hex')
    // Get the neccessary information to create raw transaction
    let nonce = await EtherscanServices.getNounce(senderAddress)
    let gasPrice = await EtherscanServices.getGasPrice()
    // gasPrice *= countPercent
    gasPrice = parseInt(gasPrice)

    var tokenAmount = this.convertBalanceToWei(sendAmount, decimal)

    // Token Standards
    var transferOpCode = '0xa9059cbb'

    var ethNakedAddress = receiverAddress.toLowerCase().replace('0x', '')

    // Convert to address Token
    var ABIAddressTarget = this.zeroPadLeft(ethNakedAddress, 64)

    // Convert to value Token
    var ABIValueToTransfer = this.zeroPadLeft(tokenAmount.toString(16), 64)
    var ethData = transferOpCode + ABIAddressTarget + ABIValueToTransfer
    let gasLimit = await this.getGasLimitToken(contractAddress, gasPrice, ethData)
    // Create raw transaction
    let rawTransaction = {
      nonce: nonce,
      gasPrice: '0x' + gasPrice.toString(16),
      gasLimit: '0x' + gasLimit.toString(16),
      to: contractAddress,
      value: 0,
      data: ethData
    }
    // Create transaction and sign with private key
    var transaction = new EthereumTx(rawTransaction)
    transaction.sign(privateKey)
    // Serialize and convert transaction to hex
    let serializedTransaction = transaction.serialize()
    let hexSerializedTransaction = '0x' + serializedTransaction.toString('hex')

    return EtherscanServices.sendRawTransaction(hexSerializedTransaction)
  }

  /**
   * NAME: getTxChildListFromAddressByPageAndOffset
   * PARAMS: page number
   * Get the transaction based on page number
   * RETURN
   */
  static async getTxChildListFromAddressByPageAndOffset (address, pageNumber, offset) {
    let txChildList = await EtherscanServices.getNormalTransactionByAddress(address, pageNumber, offset)
    return txChildList
  }
}
